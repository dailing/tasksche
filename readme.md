# task scheduler

## Features

* dependence check, change detection continuous development
* Inheritance of task configuration, and code from parent tasks
  * The run function is defined in the last parent
  * The nearest parameter overrides the parent

TODO:

* reproducible
* trigger
* add multi-thread runner
* add command line interface to select the runner
* build frontend
* emit sche event
* resource tags
* cluster support?
* generator

generator design:

generator and collector should be defined explicitly in the config header.

* The on_start of a generator with CallBackEvent.iter == None should start
  a new generator, it will set the CallBackEvent.iter to 0 and call on_iter of itself.
* the on_iter function of child tasks should be called when the generator generates a new
  value.

behaviors of tasks depend on a generator:

* normal task: the mod.run will be called when the generator generates a new value,
  the task can only accept a single generator as input, mod may be deleted before the
  next call
* generator task: the mod.run will be called when the generator generates a new value,
  the mod will be persisted until all iters are over,
    * if the mod.run yields multiple values, the child tasks will be executed for each
      value
    * if stop iteration is generated by root, it will be passed to all child tasks, child
      task will determine whether to stop the iteration or not
* Collector task: the mod.run will be called when the generator generates a new value,
    * the mod will be persisted until all iters are over,
    * if stop iteration is generated by root, a Finish event will be generated, and the
      mod.gether function is called.


```mermaid
sequenceDiagram
    participant _START_
    participant task1;
    participant task2_G;
    participant task3;
    participant task4_C;
    participant _END_;
    autonumber
    Note over _START_, _END_: feed input;
    Note over _START_: on_start<br/>on_task_finish;
    _START_ ->> task1: on_task_finish;
    Note over task1: on_ready<br/>on_start<br/>on_run;
    task1->>task2_G: on_task_finish;
    Note over task2_G: ready-start;
    loop Every iter i
        rect lightblue
        Note over task2_G: on_iter_i;
        task2_G->>task3: on_finish_iter_i;
        Note over task3: ready_iter_i<br/>run_iter_i<br/>finish_iter_i;
        task3 ->> task4_C: on_task_finish;
        Note over task4_C: on_collect;
        end
    end
    task2_G ->>task3: on_iter_stop;
    task3 ->>task4_C: on_iter_stop;
    Note over task4_C: on_task_finish;
    task4_C ->> _END_: on_task_finish;
    Note over _END_, _START_: finish_all;
```
